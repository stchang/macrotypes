#lang racket

(match-define (list i1 o1 id1 err1 f1)
  (process "time racket run-mlish-tests1.rkt"))
(match-define (list i1b o1b id1b err1b f1b)
  (process "time racket run-mlish-tests1b.rkt"))
(match-define (list i2 o2 id2 err2 f2)
  (process "time racket run-mlish-tests2.rkt"))
(match-define (list i3 o3 id3 err3 f3)
  (process "time racket mlish/bg/basics.mlish"))
(match-define (list i3b o3b id3b err3b f3b)
  (process "time racket mlish/bg/basics2.mlish"))
(match-define (list i3c o3c id3c err3c f3c)
  (process "time racket run-mlish-tests3.rkt"))
(match-define (list i4 o4 id4 err4 f4)
  (process "time racket mlish/polyrecur.mlish"))

(displayln "----- General tests and queens: ---------------------------------")
(write-string (port->string err1))
(write-string (port->string i1))
(displayln "----- Shootout tests: -------------------------------------------")
(write-string (port->string err1b))
(write-string (port->string i1b))
(displayln "----- RW OCaml tests: -------------------------------------------")
(write-string (port->string err2))
(write-string (port->string i2))
(displayln "----- Ben's tests: ----------------------------------------------")
(write-string (port->string err3))
(write-string (port->string i3))
(write-string (port->string err3b))
(write-string (port->string i3b))
(write-string (port->string err3c))
(write-string (port->string i3c))
(displayln "----- Okasaki / polymorphic recursion tests: --------------------")
(write-string (port->string err4))
(write-string (port->string i4))

(close-input-port i1)
(close-output-port o1)
(close-input-port err1)
(close-input-port i1b)
(close-output-port o1b)
(close-input-port err1b)
(close-input-port i2)
(close-output-port o2)
(close-input-port err2)
(close-input-port i3)
(close-output-port o3)
(close-input-port err3)
(close-input-port i3b)
(close-output-port o3b)
(close-input-port err3b)
(close-input-port i3c)
(close-output-port o3c)
(close-input-port err3c)
(close-input-port i4)
(close-output-port o4)
(close-input-port err4)

;; (require "mlish-tests.rkt")
;; (require "mlish/queens.mlish")
;; (require "mlish/trees.mlish")
;; (require "mlish/chameneos.mlish")
;; (require "mlish/ack.mlish")
;; (require "mlish/ary.mlish")
;; (require "mlish/fannkuch.mlish")
;; (require "mlish/fasta.mlish")
;; (require "mlish/fibo.mlish")
;; (require "mlish/hash.mlish")
;; ;(require "mlish/heapsort.mlish")
;; (require "mlish/knuc.mlish")
;; (require "mlish/matrix.mlish")
;; (require "mlish/nbody.mlish")

;; ;; from rw ocaml
;; (require "mlish/term.mlish")
;; (require "mlish/find.mlish")
;; (require "mlish/alex.mlish")
;; (require "mlish/inst.mlish")
;; (require "mlish/result.mlish")

;; ;; bg
;; (require "mlish/bg/basics.mlish")
;; (require "mlish/bg/huffman.mlish")
;; (require "mlish/bg/lambda.rkt")

;; ;; okasaki, polymorphic recursion
;; (require "mlish/polyrecur.mlish")
