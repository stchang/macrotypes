2016-09-08 --------------------

** Problem: Constant is unsound:

(define-symbolic f (~> integer? boolean?))
(define-symbolic x integer?)
(define sol (solve (assert (not (equal? (f x) (f 1))))))
(define res (evaluate x sol))

res has type (Constant Int) but (constant? res) is false

** Workaround: special case in evaluate
 - still unsound with polymorphism

2016-09-08 --------------------

Typed Rosette tricky subtyping examples:

***** Both these should be true:

(Constant Int) <: (U (Constant Int) (Constant Bool))
(Constant Int) <: Int = (U CInt)

However, the first case will not hold unless the (rhs) U subtyping clause
appears first, but the second case will not hold unless the (lhs) Constant
subtyping clause appears first.

Bad alternative: put (lhs) Constant clause first, but attach stx prop
Con: complicated bc must propagate stx prop whenever descending lhs type

Bad alternative: Perform reductions on U of Constants?
Possibly?: (U (Constant Int) (Constant Bool)) -> (U Int Bool)
But then, (U (Constant Int)) <: (U Int), which should *not* hold.

Bad alternative: lift Constant out of U
Con: non-constant values, eg (if b i1 i2) will be recognized as "constant"

*Current design choice*: disallow first case

Another alternative: get rid of Constant altogether?

SUMMARY: 
Here are the above two cases in canonical form:

(Constant* (U* CInt)) <: (U* (Constant* (U* CInt)) (Constant* (U* CBool)))
(Constant* (U* CInt)) <: (U* CInt)

The problem is that each case requires a different rule but the outer type
constructors are insufficient for determining which rule use.


2016-09-02 --------------------

Is concrete? broken?
- ie, Is it correct to determine concreteness from only outermost constructor?
- eg, an equal? that returns CBool based on concrete? inputs is not correct:
  (equal? (list i) (list 1)) => (= i 1)
  - is this a problem with concrete? or equal?

2016-08-31 --------------------

Rosette TODO:
- fix documentation of synthesize
  - #:forall accepts everything, not just constant?s
- doc typo: core
 - Returns the unsatisfiable core stored in the given satisfiable solution

Rosette use case questions:
- does the predicate in define-symbolic need to be an arbitrary expression?

2016-08-31 --------------------

Adding typed define/debug, debug (from query/debug), render (from lib/query):
- revealed problems with the way Rosette tracks source locations
  - in query/debug.rkt: https://github.com/emina/rosette/blob/cb877b9094f368c5f392518e7538ae8a061433a2/rosette/query/debug.rkt#L38
  - specifically, make-variable-like-transformer does not preserve src loc 
  properly, see: https://github.com/emina/rosette/issues/40

Workaround: manually set the src loc in #%app to surface program
- this causes taint problems bc rosette #%app uses syntax-rules, which taints 
  its output, which causes problems when we try to destructure it
minimal example:
#lang racket
(require (for-syntax syntax/parse))
(define-syntax-rule (mac x)
  (#%app add1 x))
(define-syntax test
  (syntax-parser
    [(_ x)
     #:with e (local-expand #'(mac x) 'expression null)
     (datum->syntax #'e (syntax-e #'e))]))
(test 1)
- calling syntax-disarm on the expanded pieces of a Rosette #%app appears to
  prevent the taint errors

2016-08-29 --------------------

Interesting parts of Typed Rosette
- only need a single U symbolic constructor
- assert-type, using cast-type and assertion store
- solvable?, function?, typefor tags
- Constant constructor?

2016-08-25 --------------------

TODOs:
- add pred properties to types 
 - use it to validate given pred in define-symbolic
 - STARTED 2016-08-25
 - alternative: don't require type, but associate type with pred?
   - advantage: soundness
   - disadvantage: cannot compute pred in define-symbolic
     - Rosette users won't care?
     - TODO: add extra type rules to propagate 'typefor tag
 - DONE (alternative) 2016-09-07
- implement assert-type, which adds to the assertion store
 - DONE 2016-08-25
- add polymorphism
 - regular polymorphism
 - BV size polymorphism?
- extend BV type with a size
 - requires BV-size-polymorpism?
- add Any type?
 - STARTED 2016-08-26 DONE?
- support internal definition contexts
- fix type of Vector and List to differentiate homogeneous/hetero
  - 2016-09-01: add CList for hetero lists
- variable arity polymorphism
- CSolution
   - DONE 2016-08-30
- make libs have appropriate require paths
  - eg typed/rosette/query/debug
- make typed/rosette a separate pkg
  - depends on macrotypes and rosette
- create version of turnstile that does not provide #%module-begin
  - eg rename existing turnstile to turnstile/lang?
  - DONE, see Alex's commit 2016-08-31
   - fixed set! bug
- remove my-this-syntax stx param
- add symbolic True and False?
- orig stx prop confuses distinction between symbolic and non-sym values
  in err msgs
- use variance information in type constructors?
  - instead of special-casing individual constructors
- ok to say "Rosette type" in type err msgs?
- ADD 2016-09-08: fix Constant soundness wrt evaluate
- ADD 2016-09-08: transfer "typefor" and "solvable?" props to id in define
  - DONE 2016-09-08
- is there a way to determine when evaluate produces concrete vals?

2016-08-25 --------------------

** Problem:

The following subtyping relation holds but is potentially unintuitive for a 
programmer:

(U Int Bool) <: (U CInt Bool)

** Possible Solutions:
1) leave as is
2) allow only symbolic arguments to user-facing U constructor
 - user-facing U constructor expands to U** flattening constructor,
   which then expands to internal U* constructor
 - disadvantage: an if expression will expose the internal U** constructor,
   since if may need to create a symbolic union from potentially concrete types

Choosing #1 for now.
